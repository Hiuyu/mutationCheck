{
    "collab_server" : "",
    "contents" : "#######################################################################\n# ToDo:  Check variants from BAM file, do hard-filtering and recalculate supporting\n#           reads for alterate and reference alleles and VAF (variant allele frequency).\n#        Assume the tumor and normal bam have a same naming style such as ${sample_id}_{T,B}.bam.\n#\n# Dependencies: Rsamtools, GenomicAlignments, stringr, Biostrings\n#\n# Input:  Argument 1: a mutation_file that should have the following columns with no header name.\n#         But \"#\" line is allowed.\n#           columns:\n#           1: SAMPLE id\n#           2: chromosome\n#           3: position in 1-base coordination\n#           4: reference allele\n#           5: alterate allele\n#           6: gene symbol (optional, not require)\n#         Argument 2: output filenames\n#\n# Output: a table with the same lines and the first several columns as mutation_file,\n#         and add several columns after.\n#           1: tumor.total.reads, total reads spanning the variant positions(including lowQual reads) in tumor.\n#           2: tumor.pass.reads, number of reads that pass the read quality filters in tumor.\n#           3: tumor.AD, reads supporting alterate alleles in tumor\n#           4: tumor.RD, reads supporting reference alleles in tumor\n#           5: tumor.VAF, variant allele frequency in tumor, VAF=AD/(AD+RD)\n#           6: tumor.total.reads, total reads spanning the variant positions(including lowQual reads) in normal.\n#           7: tumor.pass.reads, number of reads that pass the read quality filters in normal.\n#           8: normal.AD, reads supporting alterate alleles in normal\n#           9: normal.RD, reads supporting reference alleles in normal\n#           10: normal.VAF, variant allele frequency in normal, VAF=AD/(AD+RD)\n#           11: map.uniq, is the sequence around variant uniquely mapped to genome, thus less possibility of multiple\n#               alignment or mapping error. TRUE or FALSE. ( Tue Jun 20 09:59:15 2017)\n#           12: suppl.align, if map.uniq == FALSE, we could know how many regions are similar as the query one,\n#               and the details. ( Tue Jun 20 12:33:15 2017)\n#\n# Usage:  Rscript variant_check_recalc_VAF_from_BAM.R mutation_file output_file\n#\n# Author: Xiao-yu Zuo\n# date: Thu Jun 15 10:03:25 2017\n#\n# History:\n# Tue Jun 20 09:59:15 2017 ------------------------------\n#   Blast for sequences around variants.\n#######################################################################\n# Mon Jun 19 15:52:26 2017 ------------------------------\n# suppress message\nsuppressMessages(library(Rsamtools))\nsuppressMessages(library(GenomicAlignments))\nsuppressMessages(library(stringr))\n\n# parse argument\nargs=commandArgs(TRUE)\nmutation_file = as.character(args[1])\noutput_file = as.character(args[2])\npath_to_bam = \"/data/home/zuoxy/data/NPC/somatic/20160519_863closing/0-bam_GD/\" # manual modify\nbam_surfix = \".bam\" # manual modify\n\n# set blast parameters and reference genome\nref_fasta = \"/data/public/HomoSapiens/hg19/ucsc_hg19.fasta\"\nblast_dir = \"/share/apps/blast/2.3.0/bin/\" # path to blastn\nblast_flank_bp = 150 # used to extract reference sequence of variants +- blast_flank_bp bps\nblast_db = \"/data/public/HomoSapiens/blastDB/hg19/ucsc_hg19\" # blastdb path\nnt = 2 # threads used in blastn\n\nmutations = read.table(mutation_file, header=FALSE,sep=\"\\t\",stringsAsFactors = FALSE, comment.char = \"#\")\ncolnames(mutations) = c(\"sample\",\"chr\",\"pos\",\"ref\",\"alt\",\"gene\")[1:ncol(mutations)]\n\n# Mon Jun 19 15:41:22 2017 ------------------------------\n# in case of letting any column to be \"logical\"\ncol.logic = colnames(mutations)[sapply(mutations,class)==\"logical\"]\nfor(s in col.logic) mutations[,s] = str_sub(as.character(mutations[,s]),1,1)\nrm(col.logic)\n\n\n##############################\n# Functions\n##############################\n#######################################################################\n# Thu Jun 15 14:53:20 2017 ------------------------------\n# check if a read is clipping by examing the cigar (S or H)\n#######################################################################\nisClipped <- function(cigar, tol=3){\n  # if clipping occurs in both side, return TRUE for not confident\n  # if clipping occurs in one side, but  > tol bases, return TRUE\n  # if no clipping or only < tol bases clipping, return FALSE\n  flag = FALSE\n  if (str_detect(cigar,\"[SH]\")) {\n    clip_str = str_extract_all(cigar,\"[0-9]+[SH]\",simplify = TRUE)\n    if (ncol(clip_str) > 1) {# has both sided clipping\n      flag = TRUE\n    } else {\n      clip_base = as.numeric(str_extract_all(clip_str,\"[0-9]+\", simplify=TRUE))\n      if (clip_base > tol) { # one sided clipping but bases > tol\n        flag = TRUE\n      }\n    }\n  }\n  return(flag)\n}\n\nisClipped_mateClipped <- function(cigar, rcigar, tol=3){\n  # check for reads and their mates\n  n1 = length(cigar)\n  n2 = length(rcigar)\n  if(n1 != n2) {\n    stop(\"cigar and rcigar has unequal length! \")\n  }\n\n  isFail = sapply(1:n1, function(i){\n    isClipped(cigar[i], tol) | isClipped(rcigar[i], tol)\n  })\n\n  return(isFail)\n}\n\n#######################################################################\n#  check if a read is unimapped read, that is, no multiple alignment or\n#  supplementary alignment found for this read. By examining the 'SA' or\n#  'XA' field\n#######################################################################\nisUniMapped <- function(SA){\n  n = length(SA)\n  f = !is.na(SA)\n  if(length(f) == 1){\n    return(rep(TRUE, n))\n  }else{\n    return(!f)\n  }\n}\n\n#######################################################################\n#  check if a read has sufficient mapping quality (MAPQ)\n#######################################################################\nisPass_MAPQ <- function(MAPQ, q=30){\n  MAPQ >= q\n}\nisPass_MAPQ_mateMAPQ <- function(mq,rmq, q=30){\n  isPass_MAPQ(mq, q) & isPass_MAPQ(rmq, q)\n}\n\n#######################################################################\n# check if a read has correct insert size. (isize)\n#######################################################################\nisPass_isize <- function(isize, q=500){\n  abs(isize) < q\n}\n\n#######################################################################\n# check if a read carrying too many variants. (MD)\n#######################################################################\nisHyperMutatedRead <- function(MD, cigar, q=4){\n  # Fri Jun 16 11:20:44 2017 ------------------------------\n  # Some reads are weird as they have no \"MD:Z\" field in BAM.\n  # Perhaps after indel realignmnet, something has changed?\n  # for this case, I have to remove the reads with MD equals NA\n  # and set the reads as non-pass.\n  if(is.na(MD)){\n    return(FALSE)\n  }\n  len.md = str_count(MD, \"\\\\^*[A-Z]+\")\n  len.cigar = str_count(cigar,\"I\") # times of insertions\n  len.nm = len.md + len.cigar\n  return(len.nm >= q)\n}\n\n#######################################################################\n# convert ASCII character to its Phred quality\n#######################################################################\nconvertPhredCharacter <- function(qual, phred = 33) {\n  if(!phred %in% c(33, 64)) {\n    stop(\"phred should be only 33 or 64 !\")\n  }\n  as.numeric(charToRaw(qual)) - phred\n}\n\n#######################################################################\n#  check if a read has (q<20) bases > n%, e.g. 50% (qual)\n#######################################################################\nisTooManyLowQualBases <- function(qual, phred = 33, q = 20, tol = 0.5) {\n  # qual: bam QUAL field, the same as FASTQ QUAL field. ASCII character\n  # phred: 33 or 64, for illumina Phred+33 or +64, respectively\n  # q: threshold for base quality.\n  # tol: maximun allowed threshold\n  # return: TRUE for Yes, FALSE for No\n  qual = convertPhredCharacter(qual, phred)\n  isFail = (sum(qual < q)/length(qual)) >= tol\n  return(isFail)\n}\n\n#######################################################################\n#  check if a read carrying queried variants.\n# Thu Jun 15 15:31:55 2017 ------------------------------\n#   for this version, I have not yet check the exact sequence of insertion\n# Fri Jun 16 13:09:08 2017 ------------------------------\n#   add base quality (qual) filtering. If the mutated base is of low quality,\n#   view it as not passed reads(i.e. let isMutated = FALSE)\n#######################################################################\nisMutatedRead <- function(start, mpos, ref, alt, MD, cigar ){\n  # one read per input:\n  # start: read start;\n  # mpos: mutation position; ref: ref base; alt: alt base\n  # Note: pos, ref and alt should be 1-based coordination\n  # MD: mismatch tag; cigar: cigar;\n  # return a list() with elements\n  #   1. isMutated: TRUE: read carrying mutation, FALSE: read not carrying mutation\n  #   2. mpos: the position of mutation on this read. 0 for notfound(non-mutated reads)\n  type=\"SNP\"\n  if(ref == \"-\"){\n    type = \"INS\"\n  }else if(alt == \"-\"){\n    type = \"DEL\"\n  }\n  if(is.na(MD)) {\n    # Fri Jun 16 11:20:44 2017 ------------------------------\n    # Some reads have no MD field (NA). See isHyperMutatedRead() for detail\n    return(list(isMutated = FALSE, mpos = 0))\n  }\n  mp = mpos - start +1 # mutation point in a read\n  len = end - start + 1 # length of a read\n  clen = 0 # pos of mutation according for reference ( counts DEL)\n  rlen = 0 # pos of mutation on a read (dont count DEL)\n  isMutated = FALSE\n  if(type %in% c(\"SNP\",\"DEL\")){\n    mdz = str_match_all(MD,\"[0-9]+\\\\^*[A-Z]*\")[[1]]\n    for(j in 1:nrow(mdz)){ # iterater for each mismatch\n      x = mdz[j,]\n      a = as.numeric(str_extract(x, \"[0-9]+\"))\n      b = !is.na(str_extract(x, \"\\\\^\")) # is a DEL?\n      c = str_extract(x,\"[A-Z]+\")\n      if(is.na(c)){break} # the end of a read\n      clen = clen + a\n      rlen = rlen + a\n      if(mp - clen == 1){ # meet the mutation\n        if(type == \"SNP\" & !b & c == ref){\n          isMutated = TRUE\n          rlen = rlen + 1\n          break\n        }else if(type == \"DEL\" & b & c == ref){\n          isMutated = TRUE\n          rlen = rlen + 1\n          break\n        }\n      }\n      # if not meet the mutation, go on searching\n      clen = clen + nchar(c)\n      if(!b){# dont add rlen if DEL\n        rlen = rlen + nchar(c)\n      }\n    }\n  }else{\n    # for INS, only count cigar\n    # to update: need check the insertion bases equals to the altbases\n    mdz = str_match_all(cigar,\"[0-9]+[MID]\")[[1]]\n    for(j in 1:nrow(mdz)){ # iterater for each mismatch\n      x = mdz[j,]\n      a = as.numeric(str_extract(x, \"[0-9]+\"))\n      c = str_extract(x,\"[A-Z]+\")\n      if(c == \"M\"){\n        clen = clen + a\n        rlen = rlen + a\n      }else if(c == \"D\"){\n        clen = clen + a\n      }else if(c == \"I\"){\n        if(mp - clen == 1){\n          if(a == nchar(alt)){\n            isMutated = TRUE\n            rlen = rlen + 1\n            break\n          }\n        }\n        rlen = rlen + a\n      }\n    }\n  }\n  return(list(isMutated = isMutated, mpos = ifelse(isMutated, rlen, 0)))\n}\n\n#######################################################################\n# Thu Jun 15 14:01:12 2017 ------------------------------\n# check and QC vriants from BAM file and recalulate the AD, RD and VAF\n#######################################################################\nscan_mutation_from_bam <- function(which, ref, alt, bamName, what, flag, tag, bq.cutoff = 20){\n  # bq.cutoff: sequencing quality of nucleotide in FASTQ. bq < bq.cutoff would be removed\n  AD = 0\n  RD = 0\n  VAF = 0\n  TR = 0\n  PR = 0\n  if(is.null(what)){\n    flag = scanBamFlag(isPaired = T, isProperPair = T, isUnmappedQuery = F, hasUnmappedMate = F,\n                       isSecondaryAlignment = F, isNotPassingQualityControls = F,\n                       isDuplicate = F)\n  }\n  if(is.null(flag)){\n    what = c(\"qname\",\"flag\", \"mapq\", \"isize\", \"seq\", \"qual\")\n  }\n  if (is.null(tag)) {\n    tag = c(\"MQ\", \"MC\", \"SA\", \"MD\", \"NM\",\"XA\")\n  }\n\n  # scan bam\n  param <- ScanBamParam(flag=flag, which=which, what=what, tag=tag)\n  bamCon = BamFile(bamName, asMates = FALSE) # see $mate_status for mated pairs (?BamFile)\n  bam = as.data.frame(readGAlignments(bamCon,param=param,use.names = FALSE))\n\n  TR = nrow(bam)\n  if(TR < 1){\n    return(c(\"total.read\" = TR, \"pass.read\" = PR, \"AD\" = AD, \"RD\" = RD, \"VAF\" = VAF))\n  }\n\n  # filtering low confidence reads. TRUE for pass, FALSE for fail\n  qc_flag = sapply(1:TR, function(i){\n    flag = (!isClipped(bam$cigar[i], tol=5)) &\n      (isPass_MAPQ(bam$mapq[i])) &\n      isPass_isize(bam$isize[i]) &\n      isUniMapped(bam$SA[i]) &\n      isUniMapped(bam$XA[i]) &\n      (!isHyperMutatedRead(bam$MD[i], bam$cigar[i], q = 4)) &\n      bam$width[i] > 60\n    if(!is.na(bam$MC[i])) {\n      base_flag = flag & (!isClipped(bam$MC[i], tol=8))\n    }\n    base_flag\n  })\n\n  bam.pass = bam[qc_flag & !is.na(qc_flag),]\n  PR = nrow(bam.pass)\n\n  # if no passed reads, return FALSE QC\n  if(nrow(bam.pass) == 0) {\n    return(c(\"total.read\" = TR, \"pass.read\" = PR, \"AD\" = AD, \"RD\" = RD, \"VAF\" = VAF))\n  } else {\n    # is read carrying mutation?\n    is.mutread = rep(F, nrow(bam.pass))\n    mpos = rep(0, nrow(bam))\n    for(j in 1:nrow(bam.pass)){\n      z = isMutatedRead(bam.pass$start[j],pos,refbase,altbase,bam.pass$MD[j],bam.pass$cigar[j])\n      is.mutread[j] = z[[\"isMutated\"]]\n      mpos[j] = z[[\"mpos\"]]\n    }\n    # Fri Jun 16 13:23:47 2017 ------------------------------\n    # if the mutated bases of read i have high base quality ? cannot check for DEL\n    # if not pass, set is.mutread[i] = FALSE\n    if(alt != \"-\") { # not check for DEL\n      for(i in 1:length(is.mutread)) {\n        if(!is.mutread[i]) { # skip non-mutated reads\n          next\n        }\n        # extract qual characters. the same for SNP or INS\n        # Fri Jun 16 15:46:16 2017 ------------------------------\n        #   if cigar has H or S at the front, e.g. 2S134M, we should shift the\n        #   qual some bases (e.g. 2 for S, but 0 for H)\n        to.shift = str_match(bam.pass$cigar[i], \"[0-9]+[S]\")[1]\n        if(is.na(to.shift)) { # not found \\\\d+S, nothing change\n          to.shift = 0\n        }else{ # found S, get the shift bases\n          to.shift = as.numeric(str_extract(to.shift, \"[0-9]+\"))\n        }\n        tmp.q = str_sub(bam.pass$qual[i], mpos[i] + to.shift, mpos[i] + to.shift + length(alt) - 1)\n        tmp.q = convertPhredCharacter(tmp.q, phred = 33) # convert to number\n        if(any(tmp.q < bq.cutoff)) { # assume Q20\n          is.mutread[i] = FALSE\n        }\n      }\n    }\n\n    # recompute allele depth\n    AD = sum(is.mutread)\n    RD = sum(!is.mutread)\n    VAF =AD/(AD + RD)\n  }\n  return(c(\"total.read\" = TR, \"pass.read\" = PR, \"AD\" = AD, \"RD\" = RD, \"VAF\" = VAF))\n}\n\n\n\n#######################################################################\n# Tue Jun 20 10:27:28 2017 ------------------------------\n# BLAST to check mapping uniqueness of sequence.\n#######################################################################\nblast_check <- function(location, blast_dir, blast_db, blast_flank_bp, threads){\n  # location: a data.frame to store position of variants, with colnames.\n  #           column 1: chr, column 2: pos\n  # balst_dir: path to blastn\n  # blast_db: makeblastdb prepared blast databases.\n  # blast_flank_bp: how many basepairs around the variant should be extracted\n  # threads: threads used to do blast\n  # output: a nonduplicated data.frame with columns\n  #         1. chr\n  #         2. pos\n  #         3. uniquely mapped or not(TRUE or FALSE)?\n  suppressMessages(library(Biostrings))\n  tmpfile = tempfile(pattern = \"file\", tmpdir = tempdir(), fileext = \"\") # use temp file\n\n  location = unique(location) # make query uniqueness.\n  # set ranges to extract sequences\n  location$start = location$pos - blast_flank_bp\n  location$end = location$pos + blast_flank_bp\n  location$index = with(location, str_c(chr,\":\",pos))\n  location$pos = NULL # remove pos column\n  # build GRanges object\n  gr = makeGRangesFromDataFrame(location, ignore.strand=TRUE, keep.extra.columns=TRUE)\n\n  ## get fasta and write to file\n  fa = FaFile(ref_fasta) # load indexed fasta\n  seq = getSeq(fa, gr)\n  names(seq) = gr$index # rename seqs\n  # write tmp fasta file\n  writeXStringSet(seq, tmpfile, format = \"fasta\")\n\n  ## do blast\n  cat(\"Doing blastn, please wait for a long? time....\\n\")\n  include_flags = \"qseqid qlen sacc slen qstart qend sstart send bitscore score pident nident mismatch gaps evalue qcovs\"\n  # set command line string\n  cmd = sprintf(\"%s/blastn -query %s -db %s -outfmt '6 %s' -num_threads %i -max_target_seqs 5 -qcov_hsp_perc 50\",\n                blast_dir, tmpfile, blast_db, include_flags, nt)\n  blast_result <- read.table(pipe(cmd)) # pipe\n  # add column name\n  colnames( blast_result ) <- as.vector(str_split(include_flags,\" \",simplify = T))\n  cat(\"Blastn done! Now filtering...\\n\")\n\n  ## check multiple alignments\n  output = location\n  output$map.uniq = FALSE\n  output$suppl.align = \"\" # supplemental alignment\n  # foreach location\n  for(i in 1:nrow(output)){\n    idx = output[i,\"index\"]\n    sub.out = blast_result[blast_result$qseqid == idx, ] # get blast results subset\n    nm = nrow(sub.out) # how many match records?\n    if(nm == 0){ # nothing found\n      stop(str_c(idx,\" have nothing match!!!!\"))\n    } else if (nm == 1){ # uniquely mapped\n      if(sub.out$qend - sub.out$qstart == 2*blast_flank_bp) {\n        output[i,\"map.uniq\"] = TRUE\n      } else {\n        print(sub.out)\n        stop(str_c(idx,\" have unknown problem !!!\"))\n      }\n    } else if (nm > 1) { # multiple alignment found\n      # remove itself match\n      sub.out = subset(sub.out, !(sstart == output[i,\"start\"] & send == output[i,\"end\"] & sacc == output[i,\"chr\"]))\n      output[i, c(\"map.uniq\",\"suppl.align\")] = with(sub.out, {\n        is.sa = ((qstart <= blast_flank_bp / 2 & qend >= blast_flank_bp * 1.5)  & # read length\n            pident > 90) # similarity\n        sa = \"\"\n        if(any(is.sa)){\n          sa = with(sub.out[is.sa,], str_c(\n            sprintf(\"%s:%i-%i(%.1f)\", sacc, sstart, send, pident),\n            collapse = \";\"\n          ))\n        }\n        c(!any(is.sa), sa)\n      })\n    }\n  }\n  rm(tmpfile)\n  ## return\n  cat(\"Filtering done, return...\\n\")\n  print(head(output))\n  return(output)\n}\n\n\n\n#####################################################\nmutations$tumor.total.reads = 0\nmutations$tumor.pass.reads = 0\nmutations$tumor.AD = 0\nmutations$tumor.RD = 0\nmutations$tumor.VAF = 0\nmutations$normal.total.reads = 0\nmutations$normal.pass.reads = 0\nmutations$normal.AD = 0\nmutations$normal.RD = 0\nmutations$normal.VAF = 0\n\nib = 1 # chunk id\nchunksize = 50 # chunk size to write output\n\nflag = scanBamFlag(isPaired = T, isProperPair = T, isUnmappedQuery = F, hasUnmappedMate = F,\n                   isSecondaryAlignment = F, isNotPassingQualityControls = F,\n                   isDuplicate = F)\nwhat = c(\"qname\",\"flag\", \"mapq\", \"isize\", \"seq\", \"qual\")\ntag = c(\"MQ\", \"MC\", \"SA\", \"MD\", \"NM\", \"XA\")\n\ncat(\"Scanning BAM files start !\\n\")\n\nfor(i in 1:nrow(mutations)){\n  sample = mutations[i,1]\n  chr = mutations[i,2]\n  pos = mutations[i,3]\n  start = pos - 0\n  end = pos + 0\n  refbase = mutations[i,4]\n  altbase = mutations[i,5]\n  which = GRanges(chr,IRanges(start, end))\n  # for tumor checking\n  bamName = str_c(path_to_bam, \"/\", sample, \"_T\", bam_surfix)\n  tmp = scan_mutation_from_bam(which, refbase, altbase, bamName, what, flag, tag, bq.cutoff = 10)\n  mutations[i, c(\"tumor.total.reads\", \"tumor.pass.reads\", \"tumor.AD\", \"tumor.RD\", \"tumor.VAF\")] = tmp\n  # for normal checking\n  bamName = str_c(path_to_bam, \"/\", sample, \"_B\", bam_surfix)\n  tmp = scan_mutation_from_bam(which, refbase, altbase, bamName, what, flag, tag, bq.cutoff = 10)\n  mutations[i, c(\"normal.total.reads\", \"normal.pass.reads\", \"normal.AD\", \"normal.RD\", \"normal.VAF\")] = tmp\n\n  # logging\n  if(i %% chunksize == 0){\n    if(ib %% 10 == 0) {\n      cat(\"\\n\") # each 10 \"+\" in a row\n    }\n    cat(\"+ \")\n    ib = ib + 1\n  }\n\n}\n\ncat(\"Scanning BAM files done!\\nNow checking mapping uniqueness....\\n\")\n\n## Tue Jun 20 01:56:11 2017 ------------------------------\n## check uniqueness of sequence of +- flk bps around mutations,\n## use BLAT here is also OK, but BLAST is used here.\n#  Note that the returned data.frame is non-duplicated.\nblast_check_result = blast_check(mutations[,c(\"chr\",\"pos\")],blast_dir,blast_db,blast_flank_bp,nt)\n\n# combine\nmutations$index = with(mutations, str_c(chr, \":\", pos))\nrownames(blast_check_result) = blast_check_result$index\nmutations[index, c(\"map.uniq\", \"suppl.align\")] = blast_check_result[mutations$index, c(\"map.uniq\", \"suppl.align\")]\nmutations[,\"index\"] = NULL # remove index\n\ncat(\"Checking mapping uniqueness done!\\nNow writing output... \\n\")\n\nwrite.table(mutations,\n            file = output_file,\n            sep = \"\\t\",\n            row.names = FALSE,\n            col.names = TRUE,\n            quote = FALSE)\n\ncat(\"all done! \\n\")\n\n\n\n",
    "created" : 1498177210279.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1422129500",
    "id" : "1FCE673",
    "lastKnownWriteTime" : 1498180169,
    "last_content_update" : 1498180169616,
    "path" : "~/Documents/workspace/Github_sync_reposority/cancer_genomics/mutation_check/variant_check_recalc_VAF_from_bam.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}