{
    "collab_server" : "",
    "contents" : "##############################\n# Functions\n##############################\n#######################################################################\n# Thu Jun 15 14:53:20 2017 ------------------------------\n# check if a read is clipping by examing the cigar (S or H)\n#######################################################################\nisClipped <- function(cigar, tol=3){\n  # if clipping occurs in both side, return TRUE for not confident\n  # if clipping occurs in one side, but  > tol bases, return TRUE\n  # if no clipping or only < tol bases clipping, return FALSE\n  flag = FALSE\n  if (str_detect(cigar,\"[SH]\")) {\n    clip_str = str_extract_all(cigar,\"[0-9]+[SH]\",simplify = TRUE)\n    if (ncol(clip_str) > 1) {# has both sided clipping\n      flag = TRUE\n    } else {\n      clip_base = as.numeric(str_extract_all(clip_str,\"[0-9]+\", simplify=TRUE))\n      if (clip_base > tol) { # one sided clipping but bases > tol\n        flag = TRUE\n      }\n    }\n  }\n  return(flag)\n}\n\nisClipped_mateClipped <- function(cigar, rcigar, tol=3){\n  # check for reads and their mates\n  n1 = length(cigar)\n  n2 = length(rcigar)\n  if(n1 != n2) {\n    stop(\"cigar and rcigar has unequal length! \")\n  }\n\n  isFail = sapply(1:n1, function(i){\n    isClipped(cigar[i], tol) | isClipped(rcigar[i], tol)\n  })\n\n  return(isFail)\n}\n\n#######################################################################\n#  check if a read is unimapped read, that is, no multiple alignment or\n#  supplementary alignment found for this read. By examining the 'SA' or\n#  'XA' field\n#######################################################################\nisUniMapped <- function(SA){\n  n = length(SA)\n  f = !is.na(SA)\n  if(length(f) == 1){\n    return(rep(TRUE, n))\n  }else{\n    return(!f)\n  }\n}\n\n#######################################################################\n#  check if a read has sufficient mapping quality (MAPQ)\n#######################################################################\nisPass_MAPQ <- function(MAPQ, q=30){\n  MAPQ >= q\n}\nisPass_MAPQ_mateMAPQ <- function(mq,rmq, q=30){\n  isPass_MAPQ(mq, q) & isPass_MAPQ(rmq, q)\n}\n\n#######################################################################\n# check if a read has correct insert size. (isize)\n#######################################################################\nisPass_isize <- function(isize, q=500){\n  abs(isize) < q\n}\n\n#######################################################################\n# check if a read carrying too many variants. (MD)\n#######################################################################\nisHyperMutatedRead <- function(MD, cigar, q=4){\n  # Fri Jun 16 11:20:44 2017 ------------------------------\n  # Some reads are weird as they have no \"MD:Z\" field in BAM.\n  # Perhaps after indel realignmnet, something has changed?\n  # for this case, I have to remove the reads with MD equals NA\n  # and set the reads as non-pass.\n  if(is.na(MD)){\n    return(FALSE)\n  }\n  len.md = str_count(MD, \"\\\\^*[A-Z]+\")\n  len.cigar = str_count(cigar,\"I\") # times of insertions\n  len.nm = len.md + len.cigar\n  return(len.nm >= q)\n}\n\n#######################################################################\n# convert ASCII character to its Phred quality\n#######################################################################\nconvertPhredCharacter <- function(qual, phred = 33) {\n  if(!phred %in% c(33, 64)) {\n    stop(\"phred should be only 33 or 64 !\")\n  }\n  as.numeric(charToRaw(qual)) - phred\n}\n\n#######################################################################\n#  check if a read has (q<20) bases > n%, e.g. 50% (qual)\n#######################################################################\nisTooManyLowQualBases <- function(qual, phred = 33, q = 20, tol = 0.5) {\n  # qual: bam QUAL field, the same as FASTQ QUAL field. ASCII character\n  # phred: 33 or 64, for illumina Phred+33 or +64, respectively\n  # q: threshold for base quality.\n  # tol: maximun allowed threshold\n  # return: TRUE for Yes, FALSE for No\n  qual = convertPhredCharacter(qual, phred)\n  isFail = (sum(qual < q)/length(qual)) >= tol\n  return(isFail)\n}\n\n\n#######################################################################\n# Fri Jun 23 09:46:02 2017 ------------------------------\n# calculate overlap bases between two regions\n#######################################################################\ncomputeOverlapBases <- function(reg1, reg2) {\n  # compute how many bases in reg1 overlapping reg2\n  # return overlapped bases\n  # reg1 and reg2 is a data.frame, with column 1: chr, 2:start, 3:end\n  width = reg1$end - reg1$start + 1\n  if(class(reg2) != \"data.frame\") {\n    reg2 = as.data.frame(reg2)\n  }\n  colnames(reg1)[1:3] = c(\"chr\",\"start\",\"end\")\n  colnames(reg2)[1:3] = c(\"chr\",\"start\",\"end\")\n\n  n.r2 = nrow(reg2) # howmany regions in reg2\n  OB = rep(0, n.r2)\n\n  for(i in 1:n.r2){\n    f.chr = reg1[,\"chr\"] == reg2[i, \"chr\"]\n    s.start = reg2[i, \"start\"] - reg1[,\"start\"] # dropped bases from start\n    s.start[s.start < 0] = 0\n    s.end = reg1[, \"end\"] - reg2[i, \"end\"] # dropped bases from end\n    s.end[s.end < 0] = 0\n    OB[i] = sum(width[f.chr] - s.start[f.chr] - s.end[f.chr])\n  }\n\n  return(OB)\n}\n\n\n#######################################################################\n# Thu Jun 22 14:58:07 2017 ------------------------------\n#  Wrapper filtering low-quality reads.\n#######################################################################\nwrapper_filter_reads <- function(which, bamName, what, flag, tag){\n  TR = 0\n  PR = 0\n  TB = 0\n  PB = 0\n\n  # initialize the output list\n  output = list(\n    bam.pass = NULL, # return filter bam as a data.frame, as a format of 'samtools view *.bam chr*:*-*'.\n    # if no read left, bam.pass will return NULL\n    total.reads = TR, # total reads spanning the queried region\n    pass.reads = PR, # total reads spanning the queried region that pass the read filters\n    total.bases = TB, # total bases of a region be sequenced, note that TB = sum(read.length - outside_bases)\n    pass.bases = PB  # total bases of a region be sequenced.\n  )\n\n  if(is.null(what)){\n    flag = scanBamFlag(isPaired = T, isProperPair = T, isUnmappedQuery = F, hasUnmappedMate = F,\n                       isSecondaryAlignment = F, isNotPassingQualityControls = F,\n                       isDuplicate = F)\n  }\n  if(is.null(flag)){\n    what = c(\"qname\",\"flag\", \"mapq\", \"isize\", \"seq\", \"qual\")\n  }\n  if (is.null(tag)) {\n    tag = c(\"MQ\", \"MC\", \"SA\", \"MD\", \"NM\",\"XA\")\n  }\n\n  # scan bam\n  param <- ScanBamParam(flag=flag, which=which, what=what, tag=tag)\n  bamCon = BamFile(bamName, asMates = FALSE) # see $mate_status for mated pairs (?BamFile)\n  bam = as.data.frame(readGAlignments(bamCon,param=param,use.names = FALSE))\n\n  TR = nrow(bam)\n  if(TR < 1){ # no read cover this region\n    return(output)\n  }\n  # compute overlap bases\n  TB = computeOverlapBases(bam[,c(\"seqnames\",\"start\",\"end\")], which)\n\n  # filtering low confidence reads. TRUE for pass, FALSE for fail\n  qc_flag = sapply(1:TR, function(i){\n    flag = (!isClipped(bam$cigar[i], tol=5)) &\n      (isPass_MAPQ(bam$mapq[i])) &\n      isPass_isize(bam$isize[i]) &\n      isUniMapped(bam$SA[i]) &\n      isUniMapped(bam$XA[i]) &\n      (!isHyperMutatedRead(bam$MD[i], bam$cigar[i], q = 4)) &\n      bam$width[i] > 60\n    if(!is.na(bam$MC[i])) {\n      base_flag = flag & (!isClipped(bam$MC[i], tol=8))\n    }\n    base_flag\n  })\n\n  bam.pass = bam[qc_flag & !is.na(qc_flag),]\n  PR = nrow(bam.pass)\n\n\n  if(PR > 0){ # has pass reads\n    output[[\"bam.pass\"]] = bam.pass\n  }\n  # compute overlap bases\n  PB = computeOverlapBases(bam.pass[,c(\"seqnames\",\"start\",\"end\")], which)\n\n  # set output\n  output[[\"total.reads\"]] = TR\n  output[[\"pass.reads\"]] = PR\n  output[[\"total.bases\"]] = TB\n  output[[\"pass.bases\"]] = PB\n\n  return(output)\n}\n\n",
    "created" : 1498177848012.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4173093070",
    "id" : "E1CFBC87",
    "lastKnownWriteTime" : 1498184206,
    "last_content_update" : 1498184206588,
    "path" : "~/Documents/workspace/Github_sync_reposority/R-devel/mutationCheck/R/readQC.R",
    "project_path" : "R/readQC.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}