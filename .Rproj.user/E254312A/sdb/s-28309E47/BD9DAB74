{
    "collab_server" : "",
    "contents" : "##############################\n# Functions\n##############################\nlibrary(stringr)\nsuppressMessages(library(Rsamtools))\nsuppressMessages(library(GenomicAlignments))\n\n#######################################################################\n# Thu Jun 15 14:53:20 2017 ------------------------------\n# check if a read is clipping by examing the cigar (S or H)\n#######################################################################\nisClipped <- function(cigar, tol=3){\n  # if clipping occurs in both side, return TRUE for not confident\n  # if clipping occurs in one side, but  > tol bases, return TRUE\n  # if no clipping or only < tol bases clipping, return FALSE\n  flag = FALSE\n  if (str_detect(cigar,\"[SH]\")) {\n    clip_str = str_extract_all(cigar,\"[0-9]+[SH]\",simplify = TRUE)\n    if (ncol(clip_str) > 1) {# has both sided clipping\n      flag = TRUE\n    } else {\n      clip_base = as.numeric(str_extract_all(clip_str,\"[0-9]+\", simplify=TRUE))\n      if (clip_base > tol) { # one sided clipping but bases > tol\n        flag = TRUE\n      }\n    }\n  }\n  return(flag)\n}\n\nisClipped_mateClipped <- function(cigar, rcigar, tol=3){\n  # check for reads and their mates\n  n1 = length(cigar)\n  n2 = length(rcigar)\n  if(n1 != n2) {\n    stop(\"cigar and rcigar has unequal length! \")\n  }\n\n  isFail = sapply(1:n1, function(i){\n    isClipped(cigar[i], tol) | isClipped(rcigar[i], tol)\n  })\n\n  return(isFail)\n}\n\n#######################################################################\n#  check if a read is unimapped read, that is, no multiple alignment or\n#  supplementary alignment found for this read. By examining the 'SA' or\n#  'XA' field\n#######################################################################\nisUniMapped <- function(SA){\n  n = length(SA)\n  f = !is.na(SA)\n  if(length(f) == 1){\n    return(rep(TRUE, n))\n  }else{\n    return(!f)\n  }\n}\n\n#######################################################################\n#  check if a read has sufficient mapping quality (MAPQ)\n#######################################################################\nisPass_MAPQ <- function(MAPQ, q=30){\n  MAPQ >= q\n}\nisPass_MAPQ_mateMAPQ <- function(mq,rmq, q=30){\n  isPass_MAPQ(mq, q) & isPass_MAPQ(rmq, q)\n}\n\n#######################################################################\n# check if a read has correct insert size. (isize)\n#######################################################################\nisPass_isize <- function(isize, q=500){\n  abs(isize) < q\n}\n\n#######################################################################\n# check if a read carrying too many variants. (MD)\n#######################################################################\nisHyperMutatedRead <- function(MD, cigar, q=4){\n  # Fri Jun 16 11:20:44 2017 ------------------------------\n  # Some reads are weird as they have no \"MD:Z\" field in BAM.\n  # Perhaps after indel realignmnet, something has changed?\n  # for this case, I have to remove the reads with MD equals NA\n  # and set the reads as non-pass.\n  if(is.na(MD)){\n    return(FALSE)\n  }\n  len.md = str_count(MD, \"\\\\^*[A-Z]+\")\n  len.cigar = str_count(cigar,\"I\") # times of insertions\n  len.nm = len.md + len.cigar\n  return(len.nm >= q)\n}\n\n#######################################################################\n# convert ASCII character to its Phred quality\n#######################################################################\nconvertPhredCharacter <- function(qual, phred = 33) {\n  if(!phred %in% c(33, 64)) {\n    stop(\"phred should be only 33 or 64 !\")\n  }\n  as.numeric(charToRaw(qual)) - phred\n}\n\n#######################################################################\n#  check if a read has (q<20) bases > n%, e.g. 50% (qual)\n#######################################################################\nisTooManyLowQualBases <- function(qual, phred = 33, q = 20, tol = 0.5) {\n  # qual: bam QUAL field, the same as FASTQ QUAL field. ASCII character\n  # phred: 33 or 64, for illumina Phred+33 or +64, respectively\n  # q: threshold for base quality.\n  # tol: maximun allowed threshold\n  # return: TRUE for Yes, FALSE for No\n  qual = convertPhredCharacter(qual, phred)\n  isFail = (sum(qual < q)/length(qual)) >= tol\n  return(isFail)\n}\n\n\n#######################################################################\n# Fri Jun 23 09:46:02 2017 ------------------------------\n# calculate overlap bases between two regions\n#######################################################################\ncomputeOverlapBases <- function(reg1, reg2) {\n  # compute how many bases in reg1 overlapping reg2\n  # return overlapped bases\n  # reg1 and reg2 are GRanges objects, if GAlignment,\n  # use as(reg1, \"GRanges\") before input\n  # I think the GRanges are 1-based coordination.\n\n  hits=findOverlaps(reg1, reg2, ignore.strand=TRUE) # 1:1 index table for overlapped reads\n  reg1.df = as.data.frame(reg1[queryHits(hits)])[1:4]\n  reg2.df = as.data.frame(reg2[subjectHits(hits)])[1:4]\n  # decide the start and end of an overlap\n  s.start = ifelse(reg1.df$start > reg2.df$start, reg1.df$start, reg2.df$start)\n  s.end = ifelse(reg1.df$end < reg2.df$end, reg1.df$end, reg2.df$end)\n\n  return(sum(s.end - s.start + 1))\n\n}\n\n\n#######################################################################\n# Thu Jun 22 14:58:07 2017 ------------------------------\n#  Wrapper filtering low-quality reads.\n#######################################################################\nwrapper_filter_reads <- function(which, bamName, what, flag, tag){\n  TR = 0\n  PR = 0\n  TB = 0\n  PB = 0\n\n  # initialize the output list\n  output = list(\n    bam.pass = NULL, # return filter bam as a data.frame, as a format of 'samtools view *.bam chr*:*-*'.\n    # if no read left, bam.pass will return NULL\n    total.reads = TR, # total reads spanning the queried region\n    pass.reads = PR, # total reads spanning the queried region that pass the read filters\n    total.bases = TB, # total bases of a region be sequenced, note that TB = sum(read.length - outside_bases)\n    pass.bases = PB  # total bases of a region be sequenced.\n  )\n\n  if(is.null(what)){\n    flag = scanBamFlag(isPaired = T, isProperPair = T, isUnmappedQuery = F, hasUnmappedMate = F,\n                       isSecondaryAlignment = F, isNotPassingQualityControls = F,\n                       isDuplicate = F)\n  }\n  if(is.null(flag)){\n    what = c(\"qname\",\"flag\", \"mapq\", \"isize\", \"seq\", \"qual\")\n  }\n  if (is.null(tag)) {\n    tag = c(\"MQ\", \"MC\", \"SA\", \"MD\", \"NM\",\"XA\")\n  }\n\n  # scan bam\n  param <- ScanBamParam(flag=flag, which=which, what=what, tag=tag)\n  bamCon = BamFile(bamName, asMates = FALSE) # see $mate_status for mated pairs (?BamFile)\n  bam.gr = readGAlignments(bamCon,param=param,use.names = FALSE)\n\n  TR = length(bam.gr)\n  if(TR < 1){ # no read cover this region\n    return(output)\n  }\n  bam = as.data.frame(bam.gr)\n  # compute overlap bases\n  TB = computeOverlapBases(as(bam.gr, \"GRanges\"), which)\n\n  # filtering low confidence reads. TRUE for pass, FALSE for fail\n  qc_flag = sapply(1:TR, function(i){\n    flag = (!isClipped(bam$cigar[i], tol=5)) &\n      (isPass_MAPQ(bam$mapq[i])) &\n      isPass_isize(bam$isize[i]) &\n      isUniMapped(bam$SA[i]) &\n      isUniMapped(bam$XA[i]) &\n      (!isHyperMutatedRead(bam$MD[i], bam$cigar[i], q = 4)) &\n      bam$width[i] > 60\n    if(!is.na(bam$MC[i])) {\n      flag = flag & (!isClipped(bam$MC[i], tol=8))\n    }\n    flag\n  })\n\n  bam.pass.gr = bam.gr[qc_flag & !is.na(qc_flag),]\n  PR = length(bam.pass.gr)\n\n\n  if(PR > 0){ # has pass reads\n    output[[\"bam.pass\"]] = as.data.frame(bam.pass.gr)\n  }\n  # compute overlap bases\n  PB = computeOverlapBases(as(bam.pass.gr, \"GRanges\"), which)\n\n  # set output\n  output[[\"total.reads\"]] = TR\n  output[[\"pass.reads\"]] = PR\n  output[[\"total.bases\"]] = TB\n  output[[\"pass.bases\"]] = PB\n\n  return(output)\n}\n\n",
    "created" : 1498235125852.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1540517113",
    "id" : "BD9DAB74",
    "lastKnownWriteTime" : 1498442222,
    "last_content_update" : 1498442222573,
    "path" : "~/Documents/workspace/Github_sync_reposority/R-devel/mutationCheck/R/readQC.R",
    "project_path" : "R/readQC.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}